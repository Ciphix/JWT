// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
// Special characters, e.g., é, ö, à, etc. are supported in comments.

package jwt.actions;

import java.security.interfaces.RSAPrivateKey;
import java.util.Map; 
import java.util.HashMap; 
import java.util.Iterator;
import java.util.List;
import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator.Builder;
import com.auth0.jwt.algorithms.Algorithm;
import com.mendix.core.Core;
import com.mendix.logging.ILogNode;
import com.mendix.systemwideinterfaces.core.DataValidationRuntimeException;
import com.mendix.systemwideinterfaces.core.IContext;
import com.mendix.webui.CustomJavaAction;
import jwt.helpers.AlgorithmParser;
import jwt.helpers.AudienceListToStringArrayConverter;
import jwt.helpers.RSAKeyPairReader;
import jwt.helpers.RegisteredClaimIdentifier;
import jwt.proxies.PublicClaim;
import jwt.proxies.PublicClaimBoolean;
import jwt.proxies.PublicClaimDate;
import jwt.proxies.PublicClaimDecimal;
import jwt.proxies.PublicClaimInteger;
import jwt.proxies.PublicClaimLong;
import jwt.proxies.PublicClaimString;
import jwt.proxies.PublicClaimStringArray;
import jwt.proxies.constants.Constants;
import com.mendix.systemwideinterfaces.core.IMendixObject;

/**
 * Generates a JWT token string from a JWT object. Make sure all inputs are specified correctly. Token generation without specifying a secret, is not allowed.
 */
public class GenerateJWT extends CustomJavaAction<java.lang.String>
{
	private IMendixObject __jwtObject;
	private jwt.proxies.JWT jwtObject;
	private java.lang.String secret;
	private jwt.proxies.ENU_Algorithm algorithm;
	private IMendixObject __privateKey;
	private jwt.proxies.JWTRSAPrivateKey privateKey;

	public GenerateJWT(IContext context, IMendixObject jwtObject, java.lang.String secret, java.lang.String algorithm, IMendixObject privateKey)
	{
		super(context);
		this.__jwtObject = jwtObject;
		this.secret = secret;
		this.algorithm = algorithm == null ? null : jwt.proxies.ENU_Algorithm.valueOf(algorithm);
		this.__privateKey = privateKey;
	}

	@java.lang.Override
	public java.lang.String executeAction() throws Exception
	{
		this.jwtObject = this.__jwtObject == null ? null : jwt.proxies.JWT.initialize(getContext(), __jwtObject);

		this.privateKey = this.__privateKey == null ? null : jwt.proxies.JWTRSAPrivateKey.initialize(getContext(), __privateKey);

		// BEGIN USER CODE
		ILogNode logger = Core.getLogger(Constants.getLOGNODE());
		
		if (jwtObject == null) {
			logger.error("Input JWT object for Generate JWT is empty.");
			throw new DataValidationRuntimeException("Input JWT object for Generate JWT is empty.");
		}
		
		if (algorithm == null) {
			logger.error("Input algorithm for Generate JWT is empty.");
			throw new DataValidationRuntimeException("Input algorithm for Generate JWT is empty.");
		}
		
		RSAPrivateKey rsaPrivateKey = null;
		
		if(privateKey != null) {
			RSAKeyPairReader rsaKeyPairReader = new RSAKeyPairReader();
			rsaPrivateKey = rsaKeyPairReader.getPrivateKey(this.context(), privateKey);
		}
		
		Algorithm alg = new AlgorithmParser().parseAlgorithm(algorithm, secret, null, rsaPrivateKey);
		logger.debug("Starting to gerenate JWT token with algorithm " + alg.getName() + ".");
		
		Builder builder = JWT.create()
		        .withIssuer(jwtObject.getiss())
		        .withExpiresAt(jwtObject.getexp())
		        .withSubject(jwtObject.getsub())
		        .withJWTId(jwtObject.getjti())
		        .withNotBefore(jwtObject.getnbf())
		        .withIssuedAt(jwtObject.getiat());

		String kid = jwtObject.getkid();
		if (kid != null) {
			builder.withKeyId(kid);
		}

		/*--- set additional header claims ---*/
		List<IMendixObject> headerClaims = Core.retrieveByPath(this.context(), jwtObject.getMendixObject(), "JWT.ClaimHeader_JWT");
		if (headerClaims.size() > 0)
		{
			logger.debug("Adding " + headerClaims.size() + " headers claims.");
			Map<String,Object> headerClaimsMap = new HashMap<String,Object>();
			Iterator<IMendixObject> headerClaimIterator = headerClaims.iterator();
			while(headerClaimIterator.hasNext()) {
				IMendixObject claimObject = headerClaimIterator.next();
				PublicClaim claim = PublicClaim.initialize(this.context(), claimObject);
			
				if (claim.getClaim() != null) {
					Object claimValue = GetClaimValueObject(claim);
					if (claimValue != null)
					{
						logger.debug("Adding header claim " + claim.getClaim() + " of entity " + claim.getClass().getSimpleName() + ".");
						headerClaimsMap.put(claim.getClaim(), claimValue);
					}
					else{
						logger.warn("Incorrect specialization of PublicClaim detected for claim " + claim.getClaim() + ".");
					}
				}
			}
			if (headerClaimsMap.size() > 0)
			{
				builder.withHeader(headerClaimsMap);
			}
		}

		/* --- add audiences  ---*/
		String[] audienceList = new AudienceListToStringArrayConverter().convert(this.context(), jwtObject);
		logger.debug("Adding audience claim with " + audienceList.length + " audiences.");
		builder.withAudience(audienceList);
		
		/*--- add payload claims  ---*/
		List<IMendixObject> claims = Core.retrieveByPath(this.context(), jwtObject.getMendixObject(), "JWT.Claim_JWT");
		logger.debug("Adding " + claims.size() + " public claims.");
		Map<String,Object> payloadClaimsMap = new HashMap<String,Object>();
		Iterator<IMendixObject> payloadClaimIterator = claims.iterator();
		while(payloadClaimIterator.hasNext()) {
			IMendixObject claimObject = payloadClaimIterator.next();
			PublicClaim claim = PublicClaim.initialize(this.context(), claimObject);
		
			if (claim.getClaim() != null) {
				Object claimValue = GetClaimValueObject(claim);
				if (claimValue != null)
				{
					logger.debug("Adding claim " + claim.getClaim() + " of entity " + claim.getClass().getSimpleName() + ".");
					payloadClaimsMap.put(claim.getClaim(), claimValue);
				}
				else{
					logger.warn("Incorrect specialization of PublicClaim detected for claim " + claim.getClaim() + ".");
				}
			}
		}
		if (payloadClaimsMap.size() > 0)
		{
			builder.withPayload(payloadClaimsMap);
		}
		
		/*--- sign the token ---*/
		String token = builder.sign(alg);
		
		logger.debug("Token successfully generated.");
		
		return token;
		// END USER CODE
	}

	/**
	 * Returns a string representation of this action
	 * @return a string representation of this action
	 */
	@java.lang.Override
	public java.lang.String toString()
	{
		return "GenerateJWT";
	}

	// BEGIN EXTRA CODE

	/*--- generic method to get claim value object ---*/
	private Object GetClaimValueObject(PublicClaim claim)
	{
		if (claim.getClass() == PublicClaimBoolean.class) {
			PublicClaimBoolean claimBoolean = PublicClaimBoolean.initialize(this.context(), claim.getMendixObject());
			return(claimBoolean.getValue());
		} else if (claim.getClass() == PublicClaimDate.class) {
			PublicClaimDate claimDate = PublicClaimDate.initialize(this.context(), claim.getMendixObject());
			return(claimDate.getValue());
		} else if (claim.getClass() == PublicClaimInteger.class) {
			PublicClaimInteger claimInteger = PublicClaimInteger.initialize(this.context(), claim.getMendixObject());
			return(claimInteger.getValue());
		} else if (claim.getClass() == PublicClaimLong.class) {
			PublicClaimLong claimLong = PublicClaimLong.initialize(this.context(), claim.getMendixObject());
			return(claimLong.getValue());
		} else if (claim.getClass() == PublicClaimDecimal.class) {
			PublicClaimDecimal claimDecimal = PublicClaimDecimal.initialize(this.context(), claim.getMendixObject());
			return(claimDecimal.getValue().doubleValue());
		} else if (claim.getClass() == PublicClaimString.class) {
			PublicClaimString claimString = PublicClaimString.initialize(this.context(), claim.getMendixObject());
			return(claimString.getValue());
		} else if (claim.getClass() == PublicClaimStringArray.class) {
			/*--- new claim type array of strings */
			PublicClaimStringArray claimStringArray = PublicClaimStringArray.initialize(this.context(), claim.getMendixObject());
			String[] parts = claimStringArray.getValue().split(",");
			return(parts);

		} else {
			return(null);
		}			
	}
	/*--- CUSTOMIZATION END (use separate method to get claim value object) */
	
	// END EXTRA CODE
}
